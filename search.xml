<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>netty study</title>
      <link href="/2020/04/23/netty-study/"/>
      <url>/2020/04/23/netty-study/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty-is-fun"><a href="#Netty-is-fun" class="headerlink" title="Netty is fun!"></a>Netty is fun!</h1><blockquote><p>此文档是跟着尚硅谷 - 2020 netty源码分析及应用操作 自主学习的笔记，仅用作记录和完善知识体系架构。</p><blockquote><p>打卡记录</p><p>4-12 V6</p><p>4-14 V8</p></blockquote></blockquote><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><p>1.异步的、以事件驱动的网络应用框架<br>2.TCP/IP  –  原生jdk io/network  –  NIO  –  netty（框架）</p><h2 id="RPC框架-远程调用框架"><a href="#RPC框架-远程调用框架" class="headerlink" title="RPC框架 远程调用框架"></a>RPC框架 远程调用框架</h2><ul><li><input disabled="" type="checkbox"> </li></ul><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><ul><li><input disabled="" type="checkbox"> BIO/NIO/多路复用IO… 四种io模型</li><li><input disabled="" type="checkbox"> 确认内容</li><li><input disabled="" type="checkbox"> 同步非同步/阻塞非阻塞</li></ul><h3 id="BIO-blocking-i-o"><a href="#BIO-blocking-i-o" class="headerlink" title="BIO  blocking i/o"></a>BIO  blocking i/o</h3><ul><li><p>阻塞并同步，一个连接一个线程，如果无法立即返回，则会导致阻塞。</p></li><li><p>一个客户端创建一个线程与之通信，如果连接的客户端暂时没有数据发送，会一直阻塞在read，占用服务器资源。</p></li><li><p>适用：连接数目比较小且固定的架构，服务器要求较高。</p><p>BIO 传统IO</p><blockquote><p>简单流程</p><ul><li>服务端启动一个websocket</li><li>客户端启动socket进行通讯，（一般）服务器端需要对每一个客户端建立一个线程与之通讯</li><li>客户端发出请求后，先咨询服务器是否有空闲线程响应，如果没有则等待或遭到服务端拒绝</li><li>如果有响应，会一直等待到服务端处理完毕</li></ul></blockquote></li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><ul><li>非阻塞 同步，一个线程处理多个（通道）请求</li><li>面向缓冲区  – 数据写入到缓冲区中，需要时再可在缓冲区中前后移动， – 实现非阻塞</li><li>适用：连接数目多且连接比较短的架构，比如：聊天服务器、弹幕系统等。</li><li>三个组件：<ul><li>selector – 选择通道</li><li>channel – 通过channel read/write</li><li>buffer – 程序与buffer进行数据读写</li></ul></li></ul><h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><ul><li>JDK1.7之后存在，异步非阻塞。</li><li>适用：连接数目多且连接比较长的架构，比如：相册服务器等。充分调用OS参与操作，但是应用还不是很广泛。</li></ul><h2 id="NIO-VS-BIO"><a href="#NIO-VS-BIO" class="headerlink" title="NIO VS BIO"></a>NIO VS BIO</h2><ol><li>NIO是块读写，BIO是流读写，块的处理效率比流的效率更高</li><li>NIO非阻塞，BIO阻塞</li><li><ul><li><input disabled="" type="checkbox"> （NS） buffer 当有足够的数据读写时，线程才会处理，其余时间线程可以处理其他内容，所以是‘异步’的，而BIO每一个客户端连接，服务端就需要开启一个线程处理。</li></ul></li><li>NIO 一个线程管理多个客户端，当一个channel有事件发生时，selector选中这个通道。</li></ol>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
